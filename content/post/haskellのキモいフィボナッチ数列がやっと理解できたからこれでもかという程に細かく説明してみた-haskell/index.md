---
title: "Haskellのキモいフィボナッチ数列がやっと理解できたからこれでもかという程に細かく説明してみた #Haskell"
date: 2022-05-24T04:30:56.221Z
draft: false
featured: false
authors:
  - admin
tags:
  - Haskell
  - 新人プログラマ応援
  - フィボナッチ数列
image:
  filename: featured
  focal_point: Smart
  preview_only: false
---
\#`fib = 0 : 1 : zipWith (+) fib (tail fib)`

[こちらの記事](https://chomado.com/programming/haskell/haskell-キモいフィボナッチ数列の解読を試みる/)で紹介されていた **キモいフィボナッチ数列**がやっとの事で理解できたので, これ見よがしにドヤ顔で解説をしたいと思います.
ただ, 僕はこれを理解するので精一杯な初心者ですので, もし間違いやより良い表現等があれば教えて頂けると幸いです.


##まずは見てみる

まず問題のフィボナッチ数列はこちら

```hs:fib.hs

```

ここで注意して頂きたい点があります.
この`fib`ですが, このままだと動作しません. 実は僕は最初ここで躓いてしまい, これより先に進む事ができませんでした. ~~雑魚とか言わないで~~
この`fib`というのは, **関数ではなく定数**です(引数を取らない関数である多相定数というやつなのかなーと思っていますが, 多相定数が何なのかイマイチ理解できていません. ~~[教えてエロい人!](http://dic.nicovideo.jp/a/教えてエロい人)~~).
再帰的に定義をしていますし, いつもの関数定義のような形で書いているのでパッと見関数っぽいですが, 定数です.

\##じゃあ中身は一体どうなってるのさ

`fib`の中身は無限リストになっています. 
Haskellでは, その値が本当に必要になるまで評価を行わない**遅延評価(lazy evaluation)**が採用されています. 無限の長さのリストが扱えるのは, LazyなHaskellだからこそできる芸当ですね. どこぞの軽音楽部とは違います

> *はすける「Please say me "You are lazy!"」*

話を元に戻しましょう. 
無限リスト`fib`の中から値を取り出したい場合は, リストの先頭から`n`個の要素を取り出したリストを返す関数`take n`を用いて,

```hs:fib.hs

```

```hs:実行結果

```

このように, フィボでナッチなリストを, あなたのメモリと整数型の上限値が許す限り取り出すことができます.

\##いよいよ解読開始

ではまず定義を改めて確認していきます.

```hs:fib.hs

```

`fib :: Num a => [a]`というのは単純で, **`fib`はNum型クラスの任意のインスタンス`a`のリストを返します**, という意味になります.

`0:1:`というのは`[0, 1]++`(リスト\[0, 1]と, その後ろのリストを連結する)と同じ意味です.

関数`zipWith`は二引数関数f, リストa, bを引数に取り, a, bの要素を先頭から順にfで合成したリストを返す関数です. 
例えば`zipWith (+) [1, 2, 3] [4, 5, 6]`だと,

```hs:zipWith

```

のようになり, `[5, 7, 9]`を返します.

要するに, `fib`は, **\[0, 1]というリストに, `fib`と`tail fib`の各要素をそれぞれ足したリストを連結した無限リスト**です

`fib`の初期段階で分かっている要素は`[0, 1...]`
`tail fib`の初期段階で分かっている要素は`fib`から先頭要素を除いた`[1...]`

もうお気付きの方も多いかと思いますが, その通りです. この無限リストは, **フィボナッチ数列の最初の2つの要素に, それをずらした数列2つの要素を足し合わせたリストを連結したもの**になっています. 
フィボナッチ数列は先頭2つの要素さえあれば後は分かりますから, これで求める事が出来るのです.

\##これ見よがしの解説

まずは第1段階です. 
上に並んだ2つが

```hs:第1段階

```

3番目の要素が1である事が分かったので, リストの末尾に追加します.

```hs:第2段階

```

4番目の要素が2である事が分かったので, リストの末尾に追加.

```hs:第3段階

```

5番目の要素が3である事が分かったので(ry

```hs:第4段階

```

6番目の要素が5である(ry

```hs:第5段階

```

よって, 以下のようなリストになります.

```hs

```

\##以上です

Haskellを思い通りに書けるようになりたいけど, 読むのが精一杯でいざ実装しようとなると全く書き方(文法ではなく考え方)が分からない今日此の頃. 誰か何かおすすめの方法等あれば教えてください.